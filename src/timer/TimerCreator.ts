/**
 * Timer factory and pure computation helpers.
 */

import {
    CountdownTimer,
    CountupTimer,
    IdleTimer,
    IntervalGroup,
    IntervalSegment,
    IntervalTimer,
    TimerInstance,
    TimerPhase,
    TimerStartConfig,
} from './TimerInstance';
import { TimerContext, IDLE_TIMER_ID } from './TimerContext';
import { TimerStorageUtils } from './TimerStorageUtils';

export class TimerCreator {
    constructor(
        private ctx: TimerContext,
        private storageUtils: TimerStorageUtils,
    ) {}

    // ─── Factory ──────────────────────────────────────────────

    createTimer(config: TimerStartConfig): TimerInstance {
        const autoStart = config.autoStart === true;
        const id = config.timerType === 'idle' ? IDLE_TIMER_ID : config.taskId;
        const now = Date.now();
        const base = {
            id,
            taskId: config.timerType === 'idle' ? IDLE_TIMER_ID : config.taskId,
            taskName: config.timerType === 'idle' ? 'Idle' : config.taskName,
            taskOriginalText: config.taskOriginalText ?? '',
            taskFile: config.taskFile ?? '',
            timerTargetId: config.timerType === 'idle' ? undefined : config.timerTargetId,
            autoGeneratedTargetId: config.timerType === 'idle'
                ? false
                : this.storageUtils.isAutoManagedTimerTargetId(config.timerTargetId),
            startTimeMs: autoStart || config.timerType === 'idle' ? now : 0,
            pausedElapsedTime: 0,
            phase: config.timerType === 'idle' ? 'idle' : (autoStart ? 'work' : 'idle') as TimerPhase,
            isRunning: config.timerType === 'idle' ? true : autoStart,
            isExpanded: true,
            intervalId: null,
            customLabel: '',
            recordMode: config.recordMode ?? 'child',
            parserId: config.parserId ?? 'at-notation'
        };

        switch (config.timerType) {
            case 'pomodoro': {
                const workSec = this.ctx.plugin.settings.pomodoroWorkMinutes * 60;
                const breakSec = this.ctx.plugin.settings.pomodoroBreakMinutes * 60;
                const groups: IntervalGroup[] = [
                    {
                        segments: [
                            { label: 'Work', durationSeconds: workSec, type: 'work' },
                            { label: 'Break', durationSeconds: breakSec, type: 'break' }
                        ],
                        repeatCount: 0
                    }
                ];
                const timer: IntervalTimer = {
                    ...base,
                    timerType: 'interval',
                    intervalSource: 'pomodoro',
                    groups,
                    currentGroupIndex: 0,
                    currentSegmentIndex: 0,
                    currentRepeatIndex: 0,
                    segmentTimeRemaining: workSec,
                    totalElapsedTime: 0,
                    totalDuration: 0,
                    phase: autoStart ? 'work' : 'idle'
                };
                return timer;
            }
            case 'countup': {
                return {
                    ...base,
                    timerType: 'countup',
                    elapsedTime: 0
                };
            }
            case 'countdown': {
                const total = Math.max(1, Math.floor(config.countdownSeconds ?? this.ctx.plugin.settings.pomodoroWorkMinutes * 60));
                const timer: CountdownTimer = {
                    ...base,
                    timerType: 'countdown',
                    timeRemaining: total,
                    totalTime: total,
                    elapsedTime: 0
                };
                return timer;
            }
            case 'interval': {
                const groups = this.normalizeIntervalGroups(config.intervalGroups);
                const firstGroup = groups[0];
                const firstSegment = firstGroup.segments[0];
                const timer: IntervalTimer = {
                    ...base,
                    timerType: 'interval',
                    intervalSource: config.intervalSource,
                    groups,
                    currentGroupIndex: 0,
                    currentSegmentIndex: 0,
                    currentRepeatIndex: 0,
                    segmentTimeRemaining: firstSegment.durationSeconds,
                    totalElapsedTime: 0,
                    totalDuration: this.computeIntervalTotalDuration(groups),
                    phase: autoStart ? firstSegment.type : 'idle'
                };
                return timer;
            }
            case 'idle':
            default: {
                const timer: IdleTimer = {
                    ...base,
                    timerType: 'idle',
                    elapsedTime: 0,
                    phase: 'idle',
                    isRunning: true,
                    startTimeMs: now,
                    isExpanded: true
                };
                return timer;
            }
        }
    }

    // ─── Interval Helpers ─────────────────────────────────────

    normalizeIntervalGroups(input?: IntervalGroup[]): IntervalGroup[] {
        const normalized = (input ?? [])
            .map((group) => ({
                repeatCount: group.repeatCount === 0 ? 0 : Math.max(1, Math.floor(group.repeatCount || 1)),
                segments: (group.segments || [])
                    .map((segment) => ({
                        label: (segment.label || '').trim() || this.defaultSegmentLabel(segment.type),
                        durationSeconds: Math.max(1, Math.floor(segment.durationSeconds || 0)),
                        type: segment.type
                    }))
                    .filter((segment) => segment.durationSeconds > 0)
            }))
            .filter((group) => group.segments.length > 0);

        if (normalized.length > 0) {
            return normalized;
        }

        return this.getDefaultIntervalGroups();
    }

    computeIntervalTotalDuration(groups: IntervalGroup[]): number {
        if (groups.some((group) => group.repeatCount === 0)) {
            return 0;
        }
        return groups.reduce((total, group) => {
            const groupTotal = group.segments.reduce((sum, segment) => sum + segment.durationSeconds, 0);
            return total + groupTotal * Math.max(1, group.repeatCount);
        }, 0);
    }

    clampToTotalDuration(timer: IntervalTimer, value: number): number {
        return timer.totalDuration > 0 ? Math.min(timer.totalDuration, value) : value;
    }

    getCurrentIntervalSegment(timer: IntervalTimer): IntervalSegment | null {
        const group = timer.groups[timer.currentGroupIndex];
        if (!group) return null;
        return group.segments[timer.currentSegmentIndex] ?? null;
    }

    computeIntervalCompletedDuration(timer: IntervalTimer): number {
        let total = 0;
        for (let g = 0; g < timer.groups.length; g++) {
            const group = timer.groups[g];
            const repeats = group.repeatCount === 0
                ? (g === timer.currentGroupIndex ? timer.currentRepeatIndex : 0)
                : Math.max(1, group.repeatCount || 1);
            const groupDuration = group.segments.reduce((sum, segment) => sum + segment.durationSeconds, 0);

            if (g < timer.currentGroupIndex) {
                total += groupDuration * repeats;
                continue;
            }

            if (g > timer.currentGroupIndex) {
                break;
            }

            total += groupDuration * timer.currentRepeatIndex;
            for (let s = 0; s < timer.currentSegmentIndex; s++) {
                total += group.segments[s].durationSeconds;
            }
        }
        return total;
    }

    advanceIntervalSegment(timer: IntervalTimer): boolean {
        const currentGroup = timer.groups[timer.currentGroupIndex];
        if (!currentGroup) return false;

        if (timer.currentSegmentIndex + 1 < currentGroup.segments.length) {
            timer.currentSegmentIndex++;
            return true;
        }

        if (currentGroup.repeatCount === 0 || timer.currentRepeatIndex + 1 < Math.max(1, currentGroup.repeatCount || 1)) {
            timer.currentRepeatIndex++;
            timer.currentSegmentIndex = 0;
            return true;
        }

        if (timer.currentGroupIndex + 1 < timer.groups.length) {
            timer.currentGroupIndex++;
            timer.currentRepeatIndex = 0;
            timer.currentSegmentIndex = 0;
            return true;
        }

        return false;
    }

    // ─── Private ──────────────────────────────────────────────

    private getDefaultIntervalGroups(): IntervalGroup[] {
        return [
            {
                repeatCount: 1,
                segments: [
                    { label: 'Prepare', durationSeconds: 10, type: 'prepare' },
                    { label: 'Work', durationSeconds: this.ctx.plugin.settings.pomodoroWorkMinutes * 60, type: 'work' },
                    { label: 'Break', durationSeconds: this.ctx.plugin.settings.pomodoroBreakMinutes * 60, type: 'break' }
                ]
            }
        ];
    }

    private defaultSegmentLabel(type: IntervalSegment['type']): string {
        if (type === 'prepare') return 'Prepare';
        if (type === 'break') return 'Break';
        return 'Work';
    }
}
