/**
 * Timer persistence: serialize, deserialize, migrate, reconcile.
 */

import {
    IntervalGroup,
    IntervalTimer,
    TimerInstance,
    TimerPhase,
    TimerStartConfig,
} from './TimerInstance';
import { TimerContext, STORAGE_VERSION } from './TimerContext';
import { TimerCreator } from './TimerCreator';
import { TimerLifecycle } from './TimerLifecycle';
import { TimerRenderer } from './TimerRenderer';
import { TimerStorageUtils } from './TimerStorageUtils';
import { TaskIdGenerator } from '../utils/TaskIdGenerator';
import TaskViewerPlugin from '../main';

export interface PersistedTimer {
    id: string;
    taskId: string;
    taskName: string;
    taskOriginalText: string;
    taskFile: string;
    timerTargetId?: string;
    autoGeneratedTargetId?: boolean;
    startTimeMs: number;
    pausedElapsedTime: number;
    phase?: TimerPhase;
    mode?: 'work' | 'break' | 'idle';
    isRunning: boolean;
    isExpanded: boolean;
    customLabel: string;
    timerType: TimerStartConfig['timerType'];
    recordMode: 'child' | 'self';
    parserId: string;

    timeRemaining?: number;
    totalTime?: number;
    autoRepeat?: boolean;
    elapsedTime?: number;

    groups?: IntervalGroup[];
    currentGroupIndex?: number;
    currentSegmentIndex?: number;
    currentRepeatIndex?: number;
    segmentTimeRemaining?: number;
    totalElapsedTime?: number;
    totalDuration?: number;
    intervalSource?: 'pomodoro';
}

export interface PersistedTimerState {
    version: 5;
    ownerDeviceId: string;
    vaultFingerprint: string;
    updatedAtMs: number;
    timers: PersistedTimer[];
}

export class TimerPersistence {
    constructor(
        private ctx: TimerContext,
        private creator: TimerCreator,
        private lifecycle: TimerLifecycle,
        private renderer: TimerRenderer,
        private storageUtils: TimerStorageUtils,
    ) {}

    // ─── Persist ─────────────────────────────────────────────

    persistTimersToStorage(): void {
        const storageKey = this.storageUtils.getStorageKey();
        try {
            if (this.ctx.timers.size === 0) {
                window.localStorage.removeItem(storageKey);
                return;
            }

            const payload: PersistedTimerState = {
                version: STORAGE_VERSION,
                ownerDeviceId: this.storageUtils.deviceId,
                vaultFingerprint: this.storageUtils.vaultFingerprint,
                updatedAtMs: Date.now(),
                timers: Array.from(this.ctx.timers.values()).map((timer) => this.toPersistedTimer(timer))
            };

            window.localStorage.setItem(storageKey, JSON.stringify(payload));
        } catch (error) {
            console.error('[TimerWidget] Failed to persist timers:', error);
        }
    }

    // ─── Restore ─────────────────────────────────────────────

    restoreTimersFromStorage(onTimerRestored?: (timerId: string) => void): void {
        const storageKey = this.storageUtils.getStorageKey();
        try {
            let sourceKey = storageKey;
            let raw = window.localStorage.getItem(storageKey);
            if (!raw) {
                const legacyV4Key = this.storageUtils.getStorageKeyForVersion(4);
                raw = window.localStorage.getItem(legacyV4Key);
                sourceKey = legacyV4Key;
            }
            if (!raw) return;

            const parsed = JSON.parse(raw) as PersistedTimerState | {
                version?: number;
                ownerDeviceId?: string;
                vaultFingerprint?: string;
                updatedAtMs?: number;
                timers?: PersistedTimer[];
            };
            const normalized = this.migratePersistedState(parsed);

            if (
                !normalized
                || normalized.version !== STORAGE_VERSION
                || normalized.vaultFingerprint !== this.storageUtils.vaultFingerprint
                || !Array.isArray(normalized.timers)
            ) {
                window.localStorage.removeItem(sourceKey);
                return;
            }
            if (normalized.ownerDeviceId !== this.storageUtils.deviceId) {
                return;
            }

            for (const persisted of normalized.timers) {
                const timer = this.fromPersistedTimer(persisted);
                if (!timer) continue;

                this.reconcileRestoredTimer(timer);
                this.ctx.timers.set(timer.id, timer);
            }

            if (this.ctx.timers.size === 0) {
                this.persistTimersToStorage();
                return;
            }

            if (!this.renderer.hasContainer()) {
                this.renderer.createContainer();
            }

            for (const [timerId, timer] of this.ctx.timers) {
                if (timer.isRunning) {
                    if (timer.timerType === 'interval' && timer.segmentTimeRemaining <= 0) {
                        void this.lifecycle.handleIntervalSegmentComplete(timerId, timer);
                    } else {
                        this.lifecycle.startTimerTicker(timerId);
                    }
                }

                if (onTimerRestored) {
                    onTimerRestored(timerId);
                }
            }

            this.ctx.render();
            if (sourceKey !== storageKey) {
                window.localStorage.removeItem(sourceKey);
                this.persistTimersToStorage();
            }
        } catch (error) {
            window.localStorage.removeItem(storageKey);
            console.error('[TimerWidget] Failed to restore timers:', error);
        }
    }

    // ─── Migration ───────────────────────────────────────────

    private migratePersistedState(
        parsed: PersistedTimerState | { version?: number; ownerDeviceId?: string; vaultFingerprint?: string; updatedAtMs?: number; timers?: PersistedTimer[] }
    ): PersistedTimerState | null {
        if (!parsed || !Array.isArray(parsed.timers)) {
            return null;
        }

        if (parsed.version === STORAGE_VERSION) {
            return parsed as PersistedTimerState;
        }

        if (parsed.version === 3 || parsed.version === 4) {
            const migratedTimers = parsed.timers.map((timer) => ({
                ...timer,
                phase: timer.phase ?? timer.mode ?? 'idle'
            }));
            return {
                version: STORAGE_VERSION,
                ownerDeviceId: parsed.ownerDeviceId ?? this.storageUtils.deviceId,
                vaultFingerprint: parsed.vaultFingerprint ?? this.storageUtils.vaultFingerprint,
                updatedAtMs: parsed.updatedAtMs ?? Date.now(),
                timers: migratedTimers
            };
        }

        return null;
    }

    // ─── Serialization ───────────────────────────────────────

    private toPersistedTimer(timer: TimerInstance): PersistedTimer {
        const common: PersistedTimer = {
            id: timer.id,
            taskId: timer.taskId,
            taskName: timer.taskName,
            taskOriginalText: timer.taskOriginalText,
            taskFile: timer.taskFile,
            timerTargetId: timer.timerTargetId,
            autoGeneratedTargetId: timer.autoGeneratedTargetId,
            startTimeMs: timer.startTimeMs,
            pausedElapsedTime: timer.pausedElapsedTime,
            phase: timer.phase,
            isRunning: timer.isRunning,
            isExpanded: timer.isExpanded,
            customLabel: timer.customLabel,
            timerType: timer.timerType,
            recordMode: timer.recordMode,
            parserId: timer.parserId
        };

        switch (timer.timerType) {
            case 'countup':
                return {
                    ...common,
                    elapsedTime: timer.elapsedTime
                };
            case 'countdown':
                return {
                    ...common,
                    timeRemaining: timer.timeRemaining,
                    totalTime: timer.totalTime,
                    elapsedTime: timer.elapsedTime
                };
            case 'interval':
                return {
                    ...common,
                    groups: timer.groups,
                    currentGroupIndex: timer.currentGroupIndex,
                    currentSegmentIndex: timer.currentSegmentIndex,
                    currentRepeatIndex: timer.currentRepeatIndex,
                    segmentTimeRemaining: timer.segmentTimeRemaining,
                    totalElapsedTime: timer.totalElapsedTime,
                    totalDuration: timer.totalDuration,
                    intervalSource: timer.intervalSource
                };
            case 'idle':
            default:
                return {
                    ...common,
                    elapsedTime: timer.elapsedTime
                };
        }
    }

    private fromPersistedTimer(persisted: PersistedTimer): TimerInstance | null {
        if (!persisted || !persisted.id || !persisted.taskId) {
            return null;
        }

        const taskId = persisted.taskId;
        if (!this.lifecycle.isIdleTimer(taskId) && !taskId.startsWith('daily-') && !TaskIdGenerator.parse(taskId)) {
            return null;
        }

        const phase = (persisted.phase ?? persisted.mode ?? 'idle') as TimerPhase;
        const common = {
            id: persisted.id,
            taskId,
            taskName: persisted.taskName || 'Untitled',
            taskOriginalText: persisted.taskOriginalText || '',
            taskFile: persisted.taskFile || '',
            timerTargetId: persisted.timerTargetId,
            autoGeneratedTargetId: persisted.autoGeneratedTargetId ?? this.storageUtils.isAutoManagedTimerTargetId(persisted.timerTargetId),
            startTimeMs: persisted.startTimeMs || 0,
            pausedElapsedTime: persisted.pausedElapsedTime || 0,
            phase,
            isRunning: !!persisted.isRunning,
            isExpanded: persisted.isExpanded !== false,
            intervalId: null,
            customLabel: persisted.customLabel || '',
            recordMode: persisted.recordMode || 'child',
            parserId: persisted.parserId || 'at-notation'
        };

        switch (persisted.timerType) {
            case 'pomodoro': {
                const workSec = Math.max(1, persisted.totalTime ?? this.ctx.plugin.settings.pomodoroWorkMinutes * 60);
                const breakSec = Math.max(1, this.ctx.plugin.settings.pomodoroBreakMinutes * 60);
                const repeatCount = persisted.autoRepeat ? 0 : 1;
                const groups: IntervalGroup[] = [
                    {
                        segments: [
                            { label: 'Work', durationSeconds: workSec, type: 'work' },
                            { label: 'Break', durationSeconds: breakSec, type: 'break' }
                        ],
                        repeatCount
                    }
                ];
                const migratedInterval: IntervalTimer = {
                    ...common,
                    timerType: 'interval',
                    intervalSource: 'pomodoro',
                    groups,
                    currentGroupIndex: 0,
                    currentSegmentIndex: phase === 'break' ? 1 : 0,
                    currentRepeatIndex: 0,
                    segmentTimeRemaining: Math.max(0, persisted.timeRemaining ?? workSec),
                    totalElapsedTime: Math.max(0, persisted.pausedElapsedTime ?? 0),
                    totalDuration: repeatCount === 0 ? 0 : this.creator.computeIntervalTotalDuration(groups),
                    phase
                };
                return migratedInterval;
            }
            case 'countdown': {
                const totalTime = Math.max(1, persisted.totalTime ?? this.ctx.plugin.settings.pomodoroWorkMinutes * 60);
                const elapsedTime = Math.max(0, persisted.elapsedTime ?? persisted.pausedElapsedTime ?? 0);
                const timeRemaining = persisted.timeRemaining ?? (totalTime - elapsedTime);
                return {
                    ...common,
                    timerType: 'countdown',
                    timeRemaining,
                    totalTime,
                    elapsedTime
                };
            }
            case 'interval': {
                const groups = this.creator.normalizeIntervalGroups(persisted.groups);
                const intervalTimer: IntervalTimer = {
                    ...common,
                    timerType: 'interval',
                    intervalSource: persisted.intervalSource,
                    groups,
                    currentGroupIndex: Math.max(0, persisted.currentGroupIndex ?? 0),
                    currentSegmentIndex: Math.max(0, persisted.currentSegmentIndex ?? 0),
                    currentRepeatIndex: Math.max(0, persisted.currentRepeatIndex ?? 0),
                    segmentTimeRemaining: Math.max(0, persisted.segmentTimeRemaining ?? groups[0].segments[0].durationSeconds),
                    totalElapsedTime: Math.max(0, persisted.totalElapsedTime ?? 0),
                    totalDuration: Math.max(0, persisted.totalDuration ?? this.creator.computeIntervalTotalDuration(groups))
                };
                const segment = this.creator.getCurrentIntervalSegment(intervalTimer);
                if (!segment) {
                    return null;
                }
                if (intervalTimer.segmentTimeRemaining <= 0) {
                    intervalTimer.segmentTimeRemaining = segment.durationSeconds;
                }
                return intervalTimer;
            }
            case 'idle': {
                return {
                    ...common,
                    timerType: 'idle',
                    elapsedTime: Math.max(0, persisted.elapsedTime ?? persisted.pausedElapsedTime ?? 0),
                    phase: 'idle'
                };
            }
            case 'countup':
            default: {
                return {
                    ...common,
                    timerType: 'countup',
                    elapsedTime: Math.max(0, persisted.elapsedTime ?? persisted.pausedElapsedTime ?? 0)
                };
            }
        }
    }

    // ─── Reconciliation ──────────────────────────────────────

    private reconcileRestoredTimer(timer: TimerInstance): void {
        if (!timer.isRunning) {
            if (timer.timerType === 'countup' || timer.timerType === 'idle') {
                timer.elapsedTime = Math.max(timer.elapsedTime, timer.pausedElapsedTime);
            } else if (timer.timerType === 'countdown') {
                timer.elapsedTime = Math.max(timer.elapsedTime, timer.pausedElapsedTime);
                timer.timeRemaining = timer.totalTime - timer.elapsedTime;
                timer.phase = timer.timeRemaining < 0 ? 'idle' : 'work';
            } else if (timer.timerType === 'interval') {
                const segment = this.creator.getCurrentIntervalSegment(timer);
                if (segment) {
                    timer.segmentTimeRemaining = Math.max(0, segment.durationSeconds - timer.pausedElapsedTime);
                    timer.totalElapsedTime = this.creator.clampToTotalDuration(
                        timer,
                        this.creator.computeIntervalCompletedDuration(timer) + Math.min(segment.durationSeconds, timer.pausedElapsedTime)
                    );
                }
            }
            return;
        }

        if (timer.startTimeMs <= 0) {
            timer.startTimeMs = Date.now();
        }

        const now = Date.now();
        const currentSessionElapsed = Math.floor((now - timer.startTimeMs) / 1000);
        const totalElapsed = Math.max(0, timer.pausedElapsedTime + currentSessionElapsed);

        switch (timer.timerType) {
            case 'countup':
            case 'idle':
                timer.elapsedTime = totalElapsed;
                break;
            case 'countdown':
                timer.elapsedTime = totalElapsed;
                timer.timeRemaining = timer.totalTime - totalElapsed;
                timer.phase = timer.timeRemaining < 0 ? 'idle' : 'work';
                break;
            case 'interval': {
                const segment = this.creator.getCurrentIntervalSegment(timer);
                if (!segment) {
                    timer.segmentTimeRemaining = 0;
                    timer.totalElapsedTime = timer.totalDuration;
                    break;
                }
                timer.segmentTimeRemaining = Math.max(0, segment.durationSeconds - totalElapsed);
                timer.totalElapsedTime = this.creator.clampToTotalDuration(
                    timer,
                    this.creator.computeIntervalCompletedDuration(timer) + Math.min(segment.durationSeconds, totalElapsed)
                );
                break;
            }
            default:
                break;
        }
    }
}
