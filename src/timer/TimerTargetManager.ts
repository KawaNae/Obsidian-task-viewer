/**
 * Timer target ID management: ensure, cleanup, resolve tasks.
 */

import { TFile } from 'obsidian';
import { TimerInstance } from './TimerInstance';
import { TimerContext } from './TimerContext';
import { TimerStorageUtils } from './TimerStorageUtils';
import { TimerTaskResolver } from './TimerTaskResolver';
import { Task } from '../types';

export class TimerTargetManager {
    private resolver: TimerTaskResolver;

    constructor(
        private ctx: TimerContext,
        private storageUtils: TimerStorageUtils,
    ) {
        this.resolver = new TimerTaskResolver(ctx.plugin);
    }

    // ─── Ensure ──────────────────────────────────────────────

    async ensureTimerTargetId(taskId: string): Promise<void> {
        const timer = this.ctx.timers.get(taskId);
        if (!timer) return;
        if (timer.taskId.startsWith('daily-')) return;

        if (timer.timerTargetId) {
            timer.autoGeneratedTargetId = this.storageUtils.isAutoManagedTimerTargetId(timer.timerTargetId);
            this.ctx.persistTimersToStorage();
            return;
        }

        if (timer.parserId === 'at-notation') {
            await this.ensureInlineTimerTargetId(timer);
            return;
        }

        if (timer.parserId === 'frontmatter') {
            await this.ensureFrontmatterTimerTargetId(timer);
        }
    }

    private async ensureInlineTimerTargetId(timer: TimerInstance): Promise<void> {
        const taskIndex = this.ctx.plugin.getTaskIndex();
        const currentTask = this.resolveInlineTaskForTimer(timer);
        if (!currentTask) return;

        if (currentTask.timerTargetId) {
            timer.taskId = currentTask.id;
            timer.taskFile = currentTask.file;
            timer.taskOriginalText = currentTask.originalText;
            timer.timerTargetId = currentTask.timerTargetId;
            timer.autoGeneratedTargetId = this.storageUtils.isAutoManagedTimerTargetId(currentTask.timerTargetId);
            this.ctx.persistTimersToStorage();
            return;
        }

        if (currentTask.blockId) {
            timer.taskId = currentTask.id;
            timer.taskFile = currentTask.file;
            timer.taskOriginalText = currentTask.originalText;
            timer.timerTargetId = currentTask.blockId;
            timer.autoGeneratedTargetId = false;
            this.ctx.persistTimersToStorage();
            return;
        }

        const newTargetId = this.storageUtils.generateTimerTargetId();
        try {
            await taskIndex.updateTask(currentTask.id, { blockId: newTargetId });
            await taskIndex.waitForScan(currentTask.file);

            const updatedTask =
                this.findInlineTaskByTimerTargetId(currentTask.file, newTargetId)
                || this.resolveInlineTaskForTimer(timer);
            if (updatedTask) {
                timer.taskId = updatedTask.id;
                timer.taskFile = updatedTask.file;
                timer.taskOriginalText = updatedTask.originalText;
                timer.timerTargetId = newTargetId;
                timer.autoGeneratedTargetId = true;
                this.ctx.persistTimersToStorage();
            }
        } catch (error) {
            console.error('[TimerWidget] Failed to assign timer target ID for inline task:', error);
        }
    }

    private async ensureFrontmatterTimerTargetId(timer: TimerInstance): Promise<void> {
        const taskIndex = this.ctx.plugin.getTaskIndex();
        const currentTask = this.resolveFrontmatterTaskForTimer(timer);
        if (!currentTask) return;

        if (currentTask.timerTargetId) {
            timer.taskId = currentTask.id;
            timer.taskFile = currentTask.file;
            timer.timerTargetId = currentTask.timerTargetId;
            timer.autoGeneratedTargetId = this.storageUtils.isAutoManagedTimerTargetId(currentTask.timerTargetId);
            this.ctx.persistTimersToStorage();
            return;
        }

        const file = this.ctx.app.vault.getAbstractFileByPath(currentTask.file);
        if (!(file instanceof TFile)) return;

        const newTargetId = this.storageUtils.generateTimerTargetId();
        try {
            const timerTargetIdKey = this.ctx.plugin.settings.frontmatterTaskKeys.timerTargetId;
            // @ts-ignore - processFrontMatter is available in Obsidian API
            await this.ctx.app.fileManager.processFrontMatter(file, (frontmatter: any) => {
                frontmatter[timerTargetIdKey] = newTargetId;
            });
            await taskIndex.waitForScan(currentTask.file);

            const updatedTask =
                this.findFrontmatterTaskByTimerTargetId(newTargetId, currentTask.file)
                || this.resolveFrontmatterTaskForTimer(timer);
            if (updatedTask) {
                timer.taskId = updatedTask.id;
                timer.taskFile = updatedTask.file;
                timer.timerTargetId = newTargetId;
                timer.autoGeneratedTargetId = true;
                this.ctx.persistTimersToStorage();
            }
        } catch (error) {
            console.error('[TimerWidget] Failed to assign timer target ID for frontmatter task:', error);
        }
    }

    // ─── Cleanup ─────────────────────────────────────────────

    async cleanupGeneratedTargetId(timer: TimerInstance): Promise<void> {
        if (!timer.autoGeneratedTargetId) return;
        if (!timer.timerTargetId) return;
        if (!this.storageUtils.isAutoManagedTimerTargetId(timer.timerTargetId)) return;
        if (this.hasAnotherActiveTimerWithTarget(timer.timerTargetId)) return;

        if (timer.parserId === 'at-notation') {
            await this.removeInlineTimerTargetId(timer);
            return;
        }

        if (timer.parserId === 'frontmatter') {
            await this.removeFrontmatterTimerTargetId(timer);
        }
    }

    private hasAnotherActiveTimerWithTarget(timerTargetId: string): boolean {
        for (const timer of this.ctx.timers.values()) {
            if (timer.timerTargetId === timerTargetId) {
                return true;
            }
        }
        return false;
    }

    private async removeInlineTimerTargetId(timer: TimerInstance): Promise<void> {
        const taskIndex = this.ctx.plugin.getTaskIndex();
        let targetTask: Task | undefined;

        if (timer.taskFile) {
            targetTask = this.findInlineTaskByTimerTargetId(timer.taskFile, timer.timerTargetId!);
        }
        if (!targetTask) {
            targetTask = taskIndex
                .getTasks()
                .find((task) => task.parserId === 'at-notation' && task.timerTargetId === timer.timerTargetId);
        }
        if (!targetTask) return;

        if (targetTask.blockId !== timer.timerTargetId) {
            return;
        }

        try {
            await taskIndex.updateTask(targetTask.id, { blockId: undefined });
            await taskIndex.waitForScan(targetTask.file);
        } catch (error) {
            console.error('[TimerWidget] Failed to remove inline timer target ID:', error);
        }
    }

    private async removeFrontmatterTimerTargetId(timer: TimerInstance): Promise<void> {
        let targetPath = timer.taskFile;
        const targetTask = this.findFrontmatterTaskByTimerTargetId(timer.timerTargetId!);
        if (targetTask) {
            targetPath = targetTask.file;
        }
        if (!targetPath) return;

        const file = this.ctx.app.vault.getAbstractFileByPath(targetPath);
        if (!(file instanceof TFile)) return;

        try {
            const timerTargetIdKey = this.ctx.plugin.settings.frontmatterTaskKeys.timerTargetId;
            // @ts-ignore - processFrontMatter is available in Obsidian API
            await this.ctx.app.fileManager.processFrontMatter(file, (frontmatter: any) => {
                if (frontmatter?.[timerTargetIdKey] === timer.timerTargetId) {
                    delete frontmatter[timerTargetIdKey];
                }
            });
            await this.ctx.plugin.getTaskIndex().waitForScan(targetPath);
        } catch (error) {
            console.error('[TimerWidget] Failed to remove frontmatter timer target ID:', error);
        }
    }

    // ─── Task Resolution ─────────────────────────────────────

    private resolveInlineTaskForTimer(timer: TimerInstance): Task | undefined {
        if (timer.parserId !== 'at-notation') return undefined;
        return this.resolver.resolveInlineTask(timer);
    }

    private resolveFrontmatterTaskForTimer(timer: TimerInstance): Task | undefined {
        if (timer.parserId !== 'frontmatter') return undefined;
        return this.resolver.resolveFrontmatterTask(timer);
    }

    private findInlineTaskByTimerTargetId(filePath: string, timerTargetId: string): Task | undefined {
        return this.ctx.plugin
            .getTaskIndex()
            .getTasks()
            .find((task) =>
                task.parserId === 'at-notation'
                && task.file === filePath
                && (task.timerTargetId === timerTargetId || task.blockId === timerTargetId)
            );
    }

    private findFrontmatterTaskByTimerTargetId(timerTargetId: string, filePath?: string): Task | undefined {
        return this.ctx.plugin
            .getTaskIndex()
            .getTasks()
            .find((task) =>
                task.parserId === 'frontmatter'
                && task.timerTargetId === timerTargetId
                && (!filePath || task.file === filePath)
            );
    }
}
