/**
 * Floating Timer Widget
 * 
 * フローティングウィジェットとして複数のタイマー（Pomodoro/Countup）を管理。
 * アコーディオン形式で個別にトグル可能。
 */

import { App, setIcon, Notice, TFile, FileSystemAdapter } from 'obsidian';
import TaskViewerPlugin from '../main';
import { AudioUtils } from '../utils/AudioUtils';
import {
    CountupTimer,
    CountdownTimer,
    IdleTimer,
    IntervalGroup,
    IntervalSegment,
    IntervalTimer,
    PomodoroTimer,
    TimerInstance,
    TimerPhase,
    TimerStartConfig
} from './TimerInstance';
import { TimerRecorder } from './TimerRecorder';
import { TimerProgressUI } from './TimerProgressUI';
import { Task } from '../types';
import {
    TIMER_TARGET_ID_PREFIX,
    isTimerTargetId
} from '../utils/TimerTargetIdUtils';
import { TaskIdGenerator } from '../utils/TaskIdGenerator';
import { TimeFormatter } from '../utils/TimeFormatter';
import { TimerSettingsMenu } from './TimerSettingsMenu';
import { TimerTaskResolver } from './TimerTaskResolver';

interface PersistedTimer {
    id: string;
    taskId: string;
    taskName: string;
    taskOriginalText: string;
    taskFile: string;
    timerTargetId?: string;
    autoGeneratedTargetId?: boolean;
    startTimeMs: number;
    pausedElapsedTime: number;
    phase?: TimerPhase;
    mode?: 'work' | 'break' | 'idle';
    isRunning: boolean;
    isExpanded: boolean;
    customLabel: string;
    timerType: TimerStartConfig['timerType'];
    recordMode: 'child' | 'self';
    parserId: string;

    timeRemaining?: number;
    totalTime?: number;
    autoRepeat?: boolean;
    elapsedTime?: number;

    groups?: IntervalGroup[];
    currentGroupIndex?: number;
    currentSegmentIndex?: number;
    currentRepeatIndex?: number;
    segmentTimeRemaining?: number;
    totalElapsedTime?: number;
    totalDuration?: number;
}

interface PersistedTimerState {
    version: 4;
    ownerDeviceId: string;
    vaultFingerprint: string;
    updatedAtMs: number;
    timers: PersistedTimer[];
}

export class TimerWidget {
    private static readonly STORAGE_VERSION = 4;
    private static readonly STORAGE_KEY_PREFIX = 'task-viewer.active-timers';
    private static readonly LEGACY_STORAGE_KEY = 'task-viewer.active-timers.v2';
    private static readonly DEVICE_ID_KEY = 'task-viewer.device-id.v1';
    private static readonly IDLE_TIMER_ID = '__idle__';

    private app: App;
    private plugin: TaskViewerPlugin;
    private container: HTMLElement | null = null;
    private timers: Map<string, TimerInstance> = new Map();
    private isDragging = false;
    private dragOffset = { x: 0, y: 0 };
    private recorder: TimerRecorder;
    private resolver: TimerTaskResolver;
    private intervalPrepareBaseElapsed: Map<string, number> = new Map();
    private readonly deviceId: string;
    private readonly vaultFingerprint: string;

    constructor(app: App, plugin: TaskViewerPlugin) {
        this.app = app;
        this.plugin = plugin;
        this.recorder = new TimerRecorder(app, plugin);
        this.resolver = new TimerTaskResolver(plugin);
        this.deviceId = this.getOrCreateDeviceId();
        this.vaultFingerprint = this.resolveVaultFingerprint();
        this.cleanupLegacyStorage();
        this.restoreTimersFromStorage();
    }

    /**
     * Backward-compatible helper: open pomodoro timer.
     */
    show(
        taskId: string,
        taskName: string,
        taskOriginalText: string = '',
        taskFile: string = '',
        recordMode: 'child' | 'self' = 'child',
        parserId: string = 'at-notation',
        timerTargetId?: string
    ): void {
        this.startTimer({
            taskId,
            taskName,
            taskOriginalText,
            taskFile,
            recordMode,
            parserId,
            timerTargetId,
            timerType: 'pomodoro',
            autoStart: false
        });
    }

    /**
     * Backward-compatible helper: open countup timer.
     */
    showCountup(
        taskId: string,
        taskName: string,
        taskOriginalText: string = '',
        taskFile: string = '',
        recordMode: 'child' | 'self' = 'child',
        autoStart: boolean = false,
        parserId: string = 'at-notation',
        timerTargetId?: string
    ): void {
        this.startTimer({
            taskId,
            taskName,
            taskOriginalText,
            taskFile,
            recordMode,
            parserId,
            timerTargetId,
            timerType: 'countup',
            autoStart
        });
    }

    /**
     * Unified timer start API for all timer types.
     */
    startTimer(config: TimerStartConfig): void {
        if (!this.container) {
            this.createContainer();
        }

        const taskId = config.timerType === 'idle' ? TimerWidget.IDLE_TIMER_ID : config.taskId;
        const timerTargetId = config.timerTargetId;
        if (config.timerType !== 'idle' && this.hasActiveTimerForTask(taskId, timerTargetId)) {
            new Notice('This task already has an active timer');
            return;
        }

        if (config.timerType !== 'idle') {
            this.stopIdleTimer();
        } else if (this.timers.has(TimerWidget.IDLE_TIMER_ID)) {
            return;
        }

        const timer = this.createTimer(config);
        this.timers.set(timer.id, timer);

        if (timer.isRunning) {
            this.startTimerTicker(timer.id);
            if (timer.timerType !== 'idle') {
                AudioUtils.playStartSound();
            }
        }

        this.render();
        this.persistTimersToStorage();
        if (!this.isIdleTimer(timer.id) && !timer.taskId.startsWith('daily-')) {
            void this.ensureTimerTargetId(timer.id);
        }
    }

    private createTimer(config: TimerStartConfig): TimerInstance {
        const autoStart = config.autoStart === true;
        const id = config.timerType === 'idle' ? TimerWidget.IDLE_TIMER_ID : config.taskId;
        const now = Date.now();
        const base = {
            id,
            taskId: id,
            taskName: config.timerType === 'idle' ? 'Idle' : config.taskName,
            taskOriginalText: config.taskOriginalText ?? '',
            taskFile: config.taskFile ?? '',
            timerTargetId: config.timerType === 'idle' ? undefined : config.timerTargetId,
            autoGeneratedTargetId: config.timerType === 'idle'
                ? false
                : this.isAutoManagedTimerTargetId(config.timerTargetId),
            startTimeMs: autoStart || config.timerType === 'idle' ? now : 0,
            pausedElapsedTime: 0,
            phase: config.timerType === 'idle' ? 'idle' : (autoStart ? 'work' : 'idle') as TimerPhase,
            isRunning: config.timerType === 'idle' ? true : autoStart,
            isExpanded: true,
            intervalId: null,
            customLabel: '',
            recordMode: config.recordMode ?? 'child',
            parserId: config.parserId ?? 'at-notation'
        };

        switch (config.timerType) {
            case 'pomodoro': {
                const total = this.plugin.settings.pomodoroWorkMinutes * 60;
                const timer: PomodoroTimer = {
                    ...base,
                    timerType: 'pomodoro',
                    timeRemaining: total,
                    totalTime: total,
                    autoRepeat: false
                };
                return timer;
            }
            case 'countup': {
                return {
                    ...base,
                    timerType: 'countup',
                    elapsedTime: 0
                };
            }
            case 'countdown': {
                const total = Math.max(1, Math.floor(config.countdownSeconds ?? this.plugin.settings.pomodoroWorkMinutes * 60));
                const timer: CountdownTimer = {
                    ...base,
                    timerType: 'countdown',
                    timeRemaining: total,
                    totalTime: total,
                    elapsedTime: 0
                };
                return timer;
            }
            case 'interval': {
                const groups = this.normalizeIntervalGroups(config.intervalGroups);
                const firstGroup = groups[0];
                const firstSegment = firstGroup.segments[0];
                const timer: IntervalTimer = {
                    ...base,
                    timerType: 'interval',
                    groups,
                    currentGroupIndex: 0,
                    currentSegmentIndex: 0,
                    currentRepeatIndex: 0,
                    segmentTimeRemaining: firstSegment.durationSeconds,
                    totalElapsedTime: 0,
                    totalDuration: this.computeIntervalTotalDuration(groups),
                    phase: autoStart ? firstSegment.type : 'idle'
                };
                return timer;
            }
            case 'idle':
            default: {
                const timer: IdleTimer = {
                    ...base,
                    timerType: 'idle',
                    elapsedTime: 0,
                    phase: 'idle',
                    isRunning: true,
                    startTimeMs: now,
                    isExpanded: true
                };
                return timer;
            }
        }
    }

    private normalizeIntervalGroups(input?: IntervalGroup[]): IntervalGroup[] {
        const normalized = (input ?? [])
            .map((group) => ({
                repeatCount: Math.max(1, Math.floor(group.repeatCount || 1)),
                segments: (group.segments || [])
                    .map((segment) => ({
                        label: (segment.label || '').trim() || this.defaultSegmentLabel(segment.type),
                        durationSeconds: Math.max(1, Math.floor(segment.durationSeconds || 0)),
                        type: segment.type
                    }))
                    .filter((segment) => segment.durationSeconds > 0)
            }))
            .filter((group) => group.segments.length > 0);

        if (normalized.length > 0) {
            return normalized;
        }

        return this.getDefaultIntervalGroups();
    }

    private getDefaultIntervalGroups(): IntervalGroup[] {
        return [
            {
                repeatCount: 1,
                segments: [
                    { label: 'Prepare', durationSeconds: 10, type: 'prepare' },
                    { label: 'Work', durationSeconds: this.plugin.settings.pomodoroWorkMinutes * 60, type: 'work' },
                    { label: 'Break', durationSeconds: this.plugin.settings.pomodoroBreakMinutes * 60, type: 'break' }
                ]
            }
        ];
    }

    private computeIntervalTotalDuration(groups: IntervalGroup[]): number {
        return groups.reduce((total, group) => {
            const groupTotal = group.segments.reduce((sum, segment) => sum + segment.durationSeconds, 0);
            return total + groupTotal * Math.max(1, group.repeatCount);
        }, 0);
    }

    private defaultSegmentLabel(type: IntervalSegment['type']): string {
        if (type === 'prepare') return 'Prepare';
        if (type === 'break') return 'Break';
        return 'Work';
    }

    private createContainer(): void {
        this.container = document.body.createDiv('timer-widget');
        this.container.style.position = 'fixed';
        this.container.style.right = '20px';
        this.container.style.bottom = '20px';

        // Make draggable
        this.setupDrag();
    }

    private setupDrag(): void {
        if (!this.container) return;

        const header = this.container;

        header.addEventListener('pointerdown', (e) => {
            if ((e.target as HTMLElement).closest('.timer-widget__item')) {
                // Don't start drag if clicking inside an item
                if ((e.target as HTMLElement).closest('button, input')) return;
            }

            this.isDragging = true;
            const rect = this.container!.getBoundingClientRect();
            this.dragOffset.x = e.clientX - rect.left;
            this.dragOffset.y = e.clientY - rect.top;
            this.container!.style.cursor = 'grabbing';

            // Capture pointer for reliable tracking across boundaries
            header.setPointerCapture(e.pointerId);
        });

        header.addEventListener('pointermove', (e) => {
            if (!this.isDragging || !this.container) return;

            const x = e.clientX - this.dragOffset.x;
            const y = e.clientY - this.dragOffset.y;

            this.container.style.left = `${x}px`;
            this.container.style.top = `${y}px`;
            this.container.style.right = 'auto';
            this.container.style.bottom = 'auto';
        });

        header.addEventListener('pointerup', (e) => {
            this.isDragging = false;
            if (this.container) {
                this.container.style.cursor = 'grab';
            }
            header.releasePointerCapture(e.pointerId);
        });

        header.addEventListener('pointercancel', (e) => {
            this.isDragging = false;
            if (this.container) {
                this.container.style.cursor = 'grab';
            }
            header.releasePointerCapture(e.pointerId);
        });
    }

    private startTimerTicker(taskId: string): void {
        const timer = this.timers.get(taskId);
        if (!timer) return;
        if (timer.intervalId !== null) {
            window.clearInterval(timer.intervalId);
            timer.intervalId = null;
        }

        timer.intervalId = window.setInterval(() => {
            this.tick(taskId);
        }, 1000);
    }

    private stopTimer(taskId: string): void {
        const timer = this.timers.get(taskId);
        if (!timer || timer.intervalId === null) return;

        window.clearInterval(timer.intervalId);
        timer.intervalId = null;
    }

    private tick(taskId: string): void {
        const timer = this.timers.get(taskId);
        if (!timer || !timer.isRunning) return;

        const now = Date.now();
        const currentSessionElapsed = Math.floor((now - timer.startTimeMs) / 1000);
        const totalElapsed = Math.max(0, timer.pausedElapsedTime + currentSessionElapsed);

        switch (timer.timerType) {
            case 'countup':
            case 'idle':
                timer.elapsedTime = totalElapsed;
                this.renderTimerItem(taskId);
                return;
            case 'countdown':
                timer.elapsedTime = totalElapsed;
                timer.timeRemaining = timer.totalTime - totalElapsed;
                timer.phase = timer.timeRemaining < 0 ? 'idle' : 'work';
                this.renderTimerItem(taskId);
                return;
            case 'pomodoro':
                timer.timeRemaining = Math.max(0, timer.totalTime - totalElapsed);
                if (timer.timeRemaining > 0) {
                    this.renderTimerItem(taskId);
                } else {
                    void this.handlePomodoroComplete(taskId, timer);
                }
                return;
            case 'interval': {
                if (timer.phase === 'prepare') {
                    const baseElapsed = this.intervalPrepareBaseElapsed.get(taskId) ?? timer.totalElapsedTime;
                    timer.totalElapsedTime = baseElapsed + Math.max(0, currentSessionElapsed);
                    this.renderTimerItem(taskId);
                    return;
                }

                const segment = this.getCurrentIntervalSegment(timer);
                if (!segment) {
                    void this.finishIntervalTimer(taskId, timer);
                    return;
                }
                const segmentElapsed = Math.max(0, timer.pausedElapsedTime + currentSessionElapsed);
                timer.segmentTimeRemaining = Math.max(0, segment.durationSeconds - segmentElapsed);
                const completedBefore = this.computeIntervalCompletedDuration(timer);
                timer.totalElapsedTime = Math.min(timer.totalDuration, completedBefore + Math.min(segment.durationSeconds, segmentElapsed));

                if (timer.segmentTimeRemaining > 0) {
                    this.renderTimerItem(taskId);
                } else {
                    void this.handleIntervalSegmentComplete(taskId, timer);
                }
                return;
            }
            default:
                return;
        }
    }

    private async handlePomodoroComplete(taskId: string, timer: PomodoroTimer): Promise<void> {
        this.stopTimer(taskId);

        if (timer.phase === 'work') {
            AudioUtils.playWorkCompleteChime();
            new Notice(`🍅 ${timer.taskName} - Pomodoro complete!`);
            await this.recorder.addPomodoroRecord(timer);

            timer.phase = 'break';
            timer.timeRemaining = this.plugin.settings.pomodoroBreakMinutes * 60;
            timer.totalTime = this.plugin.settings.pomodoroBreakMinutes * 60;
            timer.startTimeMs = Date.now();
            timer.pausedElapsedTime = 0;
            timer.isRunning = true;
            this.startTimerTicker(taskId);
        } else {
            AudioUtils.playBreakCompleteChime();
            new Notice(`☕ ${timer.taskName} - Break complete!`);

            if (timer.autoRepeat) {
                timer.phase = 'work';
                timer.timeRemaining = this.plugin.settings.pomodoroWorkMinutes * 60;
                timer.totalTime = this.plugin.settings.pomodoroWorkMinutes * 60;
                timer.startTimeMs = Date.now();
                timer.pausedElapsedTime = 0;
                timer.isRunning = true;
                this.startTimerTicker(taskId);
                AudioUtils.playStartSound();
            } else {
                timer.phase = 'idle';
                timer.timeRemaining = this.plugin.settings.pomodoroWorkMinutes * 60;
                timer.totalTime = this.plugin.settings.pomodoroWorkMinutes * 60;
                timer.startTimeMs = 0;
                timer.pausedElapsedTime = 0;
                timer.isRunning = false;
            }
        }

        this.render();
        this.persistTimersToStorage();
    }

    private async handleIntervalSegmentComplete(taskId: string, timer: IntervalTimer): Promise<void> {
        this.stopTimer(taskId);
        const currentSegment = this.getCurrentIntervalSegment(timer);
        if (!currentSegment) {
            await this.finishIntervalTimer(taskId, timer);
            return;
        }

        timer.totalElapsedTime = Math.min(timer.totalDuration, this.computeIntervalCompletedDuration(timer) + currentSegment.durationSeconds);

        const moved = this.advanceIntervalSegment(timer);
        if (!moved) {
            await this.finishIntervalTimer(taskId, timer);
            return;
        }

        const nextSegment = this.getCurrentIntervalSegment(timer);
        if (!nextSegment) {
            await this.finishIntervalTimer(taskId, timer);
            return;
        }

        timer.segmentTimeRemaining = nextSegment.durationSeconds;
        timer.phase = nextSegment.type;
        timer.startTimeMs = Date.now();
        timer.pausedElapsedTime = 0;
        timer.isRunning = true;
        this.startTimerTicker(taskId);
        this.render();
        this.persistTimersToStorage();
    }

    private async finishIntervalTimer(taskId: string, timer: IntervalTimer): Promise<void> {
        this.intervalPrepareBaseElapsed.delete(taskId);
        timer.totalElapsedTime = timer.totalDuration;
        timer.segmentTimeRemaining = 0;
        timer.phase = 'idle';
        timer.isRunning = false;
        timer.startTimeMs = 0;
        timer.pausedElapsedTime = timer.totalDuration;
        this.stopTimer(taskId);

        AudioUtils.playWorkCompleteChime();
        if (timer.recordMode === 'self') {
            await this.recorder.updateTaskDirectly(timer);
        } else {
            await this.recorder.addIntervalRecord(timer);
        }
        this.closeTimer(taskId);
    }

    private getCurrentIntervalSegment(timer: IntervalTimer): IntervalSegment | null {
        const group = timer.groups[timer.currentGroupIndex];
        if (!group) return null;
        return group.segments[timer.currentSegmentIndex] ?? null;
    }

    private computeIntervalCompletedDuration(timer: IntervalTimer): number {
        let total = 0;
        for (let g = 0; g < timer.groups.length; g++) {
            const group = timer.groups[g];
            const repeats = Math.max(1, group.repeatCount || 1);
            const groupDuration = group.segments.reduce((sum, segment) => sum + segment.durationSeconds, 0);

            if (g < timer.currentGroupIndex) {
                total += groupDuration * repeats;
                continue;
            }

            if (g > timer.currentGroupIndex) {
                break;
            }

            total += groupDuration * timer.currentRepeatIndex;
            for (let s = 0; s < timer.currentSegmentIndex; s++) {
                total += group.segments[s].durationSeconds;
            }
        }
        return total;
    }

    private advanceIntervalSegment(timer: IntervalTimer): boolean {
        const currentGroup = timer.groups[timer.currentGroupIndex];
        if (!currentGroup) return false;

        if (timer.currentSegmentIndex + 1 < currentGroup.segments.length) {
            timer.currentSegmentIndex++;
            return true;
        }

        if (timer.currentRepeatIndex + 1 < Math.max(1, currentGroup.repeatCount || 1)) {
            timer.currentRepeatIndex++;
            timer.currentSegmentIndex = 0;
            return true;
        }

        if (timer.currentGroupIndex + 1 < timer.groups.length) {
            timer.currentGroupIndex++;
            timer.currentRepeatIndex = 0;
            timer.currentSegmentIndex = 0;
            return true;
        }

        return false;
    }

    private render(): void {
        if (!this.container) return;
        this.container.empty();

        if (this.timers.size === 0) {
            this.container.remove();
            this.container = null;
            return;
        }

        for (const [taskId] of this.timers) {
            this.renderTimerItem(taskId);
        }
    }

    private renderTimerItem(taskId: string): void {
        if (!this.container) return;

        const timer = this.timers.get(taskId);
        if (!timer) return;

        // Find or create item container
        let itemEl = this.container.querySelector(`[data-task-id="${taskId}"]`) as HTMLElement;
        const isNewItem = !itemEl;

        if (isNewItem) {
            itemEl = this.container.createDiv('timer-widget__item');
            itemEl.dataset.taskId = taskId;
        }
        itemEl.toggleClass('timer-widget__item--idle', this.isIdleTimer(taskId));

        // Only rebuild if new item or structure changed (e.g., expanded/collapsed toggle)
        const currentExpanded = itemEl.dataset.expanded === 'true';
        const needsRebuild = isNewItem || currentExpanded !== timer.isExpanded;

        if (needsRebuild) {
            itemEl.empty();
            itemEl.dataset.expanded = timer.isExpanded.toString();

            // Header
            const header = itemEl.createDiv('timer-widget__header');

            const titleSpan = header.createSpan('timer-widget__title');
            titleSpan.setText(timer.taskName);

            if (!timer.isExpanded) {
                // Show time in header when collapsed
                const timeSpan = header.createSpan('timer-widget__header-time');
                timeSpan.dataset.timeDisplay = 'header';
                timeSpan.setText(this.getTimerDisplayText(timer));
                timeSpan.toggleClass('timer-widget__header-time--break', timer.phase === 'break');
            }

            // Settings button (only for pomodoro)
            if (timer.timerType === 'pomodoro') {
                const settingsBtn = header.createEl('button', { cls: 'timer-widget__settings-btn' });
                setIcon(settingsBtn, 'settings');
                settingsBtn.onclick = (e) => {
                    e.stopPropagation();
                    this.showSettingsMenu(e, taskId);
                };
            }

            // Toggle button
            const toggleBtn = header.createEl('button', { cls: 'timer-widget__toggle-btn' });
            setIcon(toggleBtn, timer.isExpanded ? 'chevron-down' : 'chevron-right');
            toggleBtn.onclick = () => {
                timer.isExpanded = !timer.isExpanded;
                this.renderTimerItem(taskId);
                this.persistTimersToStorage();
            };

            // Close button
            const closeBtn = header.createEl('button', { cls: 'timer-widget__close-btn' });
            setIcon(closeBtn, 'x');
            closeBtn.onclick = () => {
                this.closeTimer(taskId);
            };

            // Expandable content
            if (timer.isExpanded) {
                const content = itemEl.createDiv('timer-widget__content');
                this.renderTimerUI(content, timer);
            }
        } else {
            // Partial update: only update time displays and progress ring
            this.updateTimerDisplay(itemEl, timer);
        }
    }

    private updateTimerDisplay(itemEl: HTMLElement, timer: TimerInstance): void {
        // Update header time (when collapsed)
        const headerTime = itemEl.querySelector('[data-time-display="header"]') as HTMLElement;
        if (headerTime) {
            headerTime.setText(this.getTimerDisplayText(timer));
            headerTime.toggleClass('timer-widget__header-time--break', timer.phase === 'break');
        }

        // Update progress ring and time display using TimerProgressUI
        TimerProgressUI.updateDisplay(itemEl, timer, this.formatSignedTime.bind(this));
    }

    private renderTimerUI(container: HTMLElement, timer: TimerInstance): void {
        // Custom label input field - only show for 'child' recordMode (not for 'self')
        if (timer.recordMode !== 'self' && timer.timerType !== 'idle') {
            const labelContainer = container.createDiv('timer-widget__label-container');
            const labelInput = labelContainer.createEl('input', {
                type: 'text',
                cls: 'timer-widget__label-input',
                placeholder: 'What are you working on? (empty = 🍅)',
                value: timer.customLabel
            });
            labelInput.oninput = () => {
                timer.customLabel = labelInput.value;
                this.persistTimersToStorage();
            };
        }

        // Circular progress
        const progressContainer = container.createDiv('timer-widget__progress-container');
        this.renderCircularProgress(progressContainer, timer);

        // Controls
        const controls = container.createDiv('timer-widget__controls');
        this.renderControls(controls, timer);
    }

    private renderCircularProgress(container: HTMLElement, timer: TimerInstance): void {
        TimerProgressUI.render(container, timer, this.formatSignedTime.bind(this));
    }

    private renderControls(container: HTMLElement, timer: TimerInstance): void {
        switch (timer.timerType) {
            case 'pomodoro':
                this.renderPomodoroControls(container, timer);
                return;
            case 'countup':
                this.renderCountupControls(container, timer);
                return;
            case 'countdown':
                this.renderCountdownControls(container, timer);
                return;
            case 'interval':
                this.renderIntervalControls(container, timer);
                return;
            case 'idle':
                this.renderIdleControls(container, timer);
                return;
            default:
                return;
        }
    }

    private renderPomodoroControls(container: HTMLElement, timer: PomodoroTimer): void {
        if (timer.phase === 'idle') {
            const startBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--primary'
            });
            setIcon(startBtn, 'play');
            startBtn.createSpan({ text: ' Start' });
            startBtn.onclick = () => {
                timer.phase = 'work';
                timer.startTimeMs = Date.now();
                timer.pausedElapsedTime = 0;
                timer.isRunning = true;
                this.startTimerTicker(timer.id);
                AudioUtils.playStartSound();
                this.render();
                this.persistTimersToStorage();
            };
        } else if (timer.isRunning) {
            const pauseBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--secondary'
            });
            setIcon(pauseBtn, 'pause');
            pauseBtn.createSpan({ text: ' Pause' });
            pauseBtn.onclick = () => {
                this.pauseTimer(timer);
                this.render();
                this.persistTimersToStorage();
            };

            const resetBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--danger'
            });
            setIcon(resetBtn, 'x');
            resetBtn.createSpan({ text: ' Reset' });
            resetBtn.onclick = () => {
                this.resetPomodoroTimer(timer.id);
            };
        } else {
            const resumeBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--primary'
            });
            setIcon(resumeBtn, 'play');
            resumeBtn.createSpan({ text: ' Resume' });
            resumeBtn.onclick = () => {
                this.resumeTimer(timer);
            };

            const resetBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--danger'
            });
            setIcon(resetBtn, 'x');
            resetBtn.createSpan({ text: ' Reset' });
            resetBtn.onclick = () => {
                this.resetPomodoroTimer(timer.id);
            };
        }
    }

    private renderCountupControls(container: HTMLElement, timer: CountupTimer): void {
        if (timer.phase === 'idle') {
            const startBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--primary'
            });
            setIcon(startBtn, 'play');
            startBtn.createSpan({ text: ' Start' });
            startBtn.onclick = () => {
                timer.phase = 'work';
                timer.startTimeMs = Date.now();
                timer.pausedElapsedTime = 0;
                timer.elapsedTime = 0;
                timer.isRunning = true;
                this.startTimerTicker(timer.id);
                AudioUtils.playStartSound();
                this.render();
                this.persistTimersToStorage();
            };
        } else if (timer.isRunning) {
            const stopBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--secondary'
            });
            setIcon(stopBtn, 'square');
            stopBtn.createSpan({ text: ' Stop' });
            stopBtn.onclick = async () => {
                this.pauseTimer(timer);
                AudioUtils.playWorkCompleteChime();

                if (timer.recordMode === 'self') {
                    await this.recorder.updateTaskDirectly(timer);
                } else {
                    await this.recorder.addSessionRecord(timer);
                }

                this.closeTimer(timer.id);
            };

            const cancelBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--danger'
            });
            setIcon(cancelBtn, 'x');
            cancelBtn.createSpan({ text: ' Cancel' });
            cancelBtn.onclick = () => {
                this.closeTimer(timer.id);
            };
        } else {
            const resumeBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--primary'
            });
            setIcon(resumeBtn, 'play');
            resumeBtn.createSpan({ text: ' Resume' });
            resumeBtn.onclick = () => {
                this.resumeTimer(timer);
            };

            const cancelBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--danger'
            });
            setIcon(cancelBtn, 'x');
            cancelBtn.createSpan({ text: ' Cancel' });
            cancelBtn.onclick = () => {
                this.closeTimer(timer.id);
            };
        }
    }

    private renderCountdownControls(container: HTMLElement, timer: CountdownTimer): void {
        if (timer.phase === 'idle' && timer.elapsedTime === 0) {
            const startBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--primary'
            });
            setIcon(startBtn, 'play');
            startBtn.createSpan({ text: ' Start' });
            startBtn.onclick = () => {
                timer.phase = 'work';
                timer.startTimeMs = Date.now();
                timer.pausedElapsedTime = 0;
                timer.elapsedTime = 0;
                timer.timeRemaining = timer.totalTime;
                timer.isRunning = true;
                this.startTimerTicker(timer.id);
                AudioUtils.playStartSound();
                this.render();
                this.persistTimersToStorage();
            };
            return;
        }

        if (timer.isRunning) {
            const stopBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--secondary'
            });
            setIcon(stopBtn, 'square');
            stopBtn.createSpan({ text: ' Stop' });
            stopBtn.onclick = async () => {
                this.pauseTimer(timer);
                AudioUtils.playWorkCompleteChime();
                if (timer.recordMode === 'self') {
                    await this.recorder.updateTaskDirectly(timer);
                } else {
                    await this.recorder.addCountdownRecord(timer);
                }
                this.closeTimer(timer.id);
            };

            const cancelBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--danger'
            });
            setIcon(cancelBtn, 'x');
            cancelBtn.createSpan({ text: ' Cancel' });
            cancelBtn.onclick = () => {
                this.closeTimer(timer.id);
            };
            return;
        }

        const resumeBtn = container.createEl('button', {
            cls: 'timer-widget__btn timer-widget__btn--primary'
        });
        setIcon(resumeBtn, 'play');
        resumeBtn.createSpan({ text: ' Resume' });
        resumeBtn.onclick = () => {
            this.resumeTimer(timer);
        };

        const cancelBtn = container.createEl('button', {
            cls: 'timer-widget__btn timer-widget__btn--danger'
        });
        setIcon(cancelBtn, 'x');
        cancelBtn.createSpan({ text: ' Cancel' });
        cancelBtn.onclick = () => {
            this.closeTimer(timer.id);
        };
    }

    private renderIntervalControls(container: HTMLElement, timer: IntervalTimer): void {
        if (timer.phase === 'idle') {
            const startBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--primary'
            });
            setIcon(startBtn, 'play');
            startBtn.createSpan({ text: ' Start' });
            startBtn.onclick = () => {
                const segment = this.getCurrentIntervalSegment(timer);
                if (!segment) return;
                timer.phase = segment.type;
                timer.segmentTimeRemaining = segment.durationSeconds;
                timer.startTimeMs = Date.now();
                timer.pausedElapsedTime = 0;
                timer.totalElapsedTime = this.computeIntervalCompletedDuration(timer);
                timer.isRunning = true;
                this.startTimerTicker(timer.id);
                AudioUtils.playStartSound();
                this.render();
                this.persistTimersToStorage();
            };
            return;
        }

        if (timer.phase === 'prepare') {
            const resumeBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--primary'
            });
            setIcon(resumeBtn, 'play');
            resumeBtn.createSpan({ text: ' Resume' });
            resumeBtn.onclick = () => {
                this.resumeTimer(timer);
            };

            const stopBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--secondary'
            });
            setIcon(stopBtn, 'square');
            stopBtn.createSpan({ text: ' Stop' });
            stopBtn.onclick = async () => {
                this.pauseOrSnapshotIntervalForStop(timer);
                AudioUtils.playWorkCompleteChime();
                if (timer.recordMode === 'self') {
                    await this.recorder.updateTaskDirectly(timer);
                } else {
                    await this.recorder.addIntervalRecord(timer);
                }
                this.closeTimer(timer.id);
            };

            const cancelBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--danger'
            });
            setIcon(cancelBtn, 'x');
            cancelBtn.createSpan({ text: ' Cancel' });
            cancelBtn.onclick = () => {
                this.closeTimer(timer.id);
            };
            return;
        }

        if (timer.isRunning) {
            const pauseBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--secondary'
            });
            setIcon(pauseBtn, 'pause');
            pauseBtn.createSpan({ text: ' Pause' });
            pauseBtn.onclick = () => {
                this.pauseIntervalToPrepare(timer);
                this.render();
                this.persistTimersToStorage();
            };

            const cancelBtn = container.createEl('button', {
                cls: 'timer-widget__btn timer-widget__btn--danger'
            });
            setIcon(cancelBtn, 'x');
            cancelBtn.createSpan({ text: ' Cancel' });
            cancelBtn.onclick = () => {
                this.closeTimer(timer.id);
            };
            return;
        }

        const resumeBtn = container.createEl('button', {
            cls: 'timer-widget__btn timer-widget__btn--primary'
        });
        setIcon(resumeBtn, 'play');
        resumeBtn.createSpan({ text: ' Resume' });
        resumeBtn.onclick = () => {
            this.resumeTimer(timer);
        };

        const stopBtn = container.createEl('button', {
            cls: 'timer-widget__btn timer-widget__btn--secondary'
        });
        setIcon(stopBtn, 'square');
        stopBtn.createSpan({ text: ' Stop' });
        stopBtn.onclick = async () => {
            this.pauseOrSnapshotIntervalForStop(timer);
            AudioUtils.playWorkCompleteChime();
            if (timer.recordMode === 'self') {
                await this.recorder.updateTaskDirectly(timer);
            } else {
                await this.recorder.addIntervalRecord(timer);
            }
            this.closeTimer(timer.id);
        };

        const cancelBtn = container.createEl('button', {
            cls: 'timer-widget__btn timer-widget__btn--danger'
        });
        setIcon(cancelBtn, 'x');
        cancelBtn.createSpan({ text: ' Cancel' });
        cancelBtn.onclick = () => {
            this.closeTimer(timer.id);
        };
    }

    private renderIdleControls(container: HTMLElement, timer: IdleTimer): void {
        const dismissBtn = container.createEl('button', {
            cls: 'timer-widget__btn timer-widget__btn--secondary'
        });
        setIcon(dismissBtn, 'x');
        dismissBtn.createSpan({ text: ' Dismiss' });
        dismissBtn.onclick = () => {
            this.closeTimer(timer.id);
        };
    }

    private pauseTimer(timer: TimerInstance): void {
        const now = Date.now();
        if (timer.startTimeMs > 0) {
            const currentSessionElapsed = Math.floor((now - timer.startTimeMs) / 1000);
            timer.pausedElapsedTime += Math.max(0, currentSessionElapsed);
        }
        timer.isRunning = false;
        this.stopTimer(timer.id);

        switch (timer.timerType) {
            case 'countup':
            case 'idle':
                timer.elapsedTime = timer.pausedElapsedTime;
                break;
            case 'countdown':
                timer.elapsedTime = timer.pausedElapsedTime;
                timer.timeRemaining = timer.totalTime - timer.elapsedTime;
                timer.phase = timer.timeRemaining < 0 ? 'idle' : 'work';
                break;
            case 'pomodoro':
                timer.timeRemaining = Math.max(0, timer.totalTime - timer.pausedElapsedTime);
                break;
            case 'interval': {
                const segment = this.getCurrentIntervalSegment(timer);
                if (!segment) break;
                timer.segmentTimeRemaining = Math.max(0, segment.durationSeconds - timer.pausedElapsedTime);
                const completedBefore = this.computeIntervalCompletedDuration(timer);
                timer.totalElapsedTime = Math.min(
                    timer.totalDuration,
                    completedBefore + Math.min(segment.durationSeconds, timer.pausedElapsedTime)
                );
                break;
            }
            default:
                break;
        }
    }

    private pauseIntervalToPrepare(timer: IntervalTimer): void {
        this.pauseTimer(timer);
        timer.phase = 'prepare';
        timer.startTimeMs = Date.now();
        timer.isRunning = true;
        this.intervalPrepareBaseElapsed.set(timer.id, timer.totalElapsedTime);
        this.startTimerTicker(timer.id);
    }

    private pauseOrSnapshotIntervalForStop(timer: IntervalTimer): void {
        if (timer.phase === 'prepare' && timer.isRunning) {
            const now = Date.now();
            const prepareElapsed = Math.max(0, Math.floor((now - timer.startTimeMs) / 1000));
            const baseElapsed = this.intervalPrepareBaseElapsed.get(timer.id) ?? timer.totalElapsedTime;
            timer.totalElapsedTime = baseElapsed + prepareElapsed;
            timer.isRunning = false;
            this.stopTimer(timer.id);
            this.intervalPrepareBaseElapsed.delete(timer.id);
            return;
        }

        if (timer.isRunning) {
            this.pauseTimer(timer);
        }
        this.intervalPrepareBaseElapsed.delete(timer.id);
    }

    private resumeTimer(timer: TimerInstance): void {
        if (timer.timerType === 'interval') {
            const segment = this.getCurrentIntervalSegment(timer);
            if (segment) {
                timer.phase = segment.type;
            }
            this.intervalPrepareBaseElapsed.delete(timer.id);
        } else if (timer.timerType === 'countdown') {
            timer.phase = timer.timeRemaining < 0 ? 'idle' : 'work';
        } else if (timer.timerType !== 'idle' && timer.phase === 'idle') {
            timer.phase = 'work';
        }
        this.stopTimer(timer.id);
        timer.startTimeMs = Date.now();
        timer.isRunning = true;
        this.startTimerTicker(timer.id);
        AudioUtils.playStartSound();
        this.render();
        this.persistTimersToStorage();
    }

    private resetPomodoroTimer(taskId: string): void {
        const timer = this.timers.get(taskId);
        if (!timer || timer.timerType !== 'pomodoro') return;

        this.stopTimer(taskId);
        timer.phase = 'idle';
        timer.timeRemaining = this.plugin.settings.pomodoroWorkMinutes * 60;
        timer.totalTime = this.plugin.settings.pomodoroWorkMinutes * 60;
        timer.startTimeMs = 0;
        timer.pausedElapsedTime = 0;
        timer.isRunning = false;
        this.render();
        this.persistTimersToStorage();
    }

    private closeTimer(taskId: string): void {
        const timer = this.timers.get(taskId);
        if (!timer) return;
        const closingIdleTimer = this.isIdleTimer(taskId);

        this.intervalPrepareBaseElapsed.delete(taskId);
        this.stopTimer(taskId);
        this.timers.delete(taskId);

        // When the last non-idle timer closes, switch to idle timer.
        if (!closingIdleTimer && !this.hasNonIdleTimers()) {
            this.startIdleTimer();
        }

        this.render();
        this.persistTimersToStorage();
        if (!closingIdleTimer) {
            void this.cleanupGeneratedTargetId(timer);
        }
    }

    private formatSignedTime(seconds: number): string {
        return TimeFormatter.formatSignedSeconds(seconds);
    }

    private getTimerDisplayText(timer: TimerInstance): string {
        switch (timer.timerType) {
            case 'countup':
            case 'idle':
                return TimeFormatter.formatSeconds(timer.elapsedTime);
            case 'countdown':
                return TimeFormatter.formatSignedSeconds(timer.timeRemaining);
            case 'interval':
                return TimeFormatter.formatSeconds(timer.segmentTimeRemaining);
            case 'pomodoro':
            default:
                return TimeFormatter.formatSeconds(timer.timeRemaining);
        }
    }

    handleFileRename(oldPath: string, newPath: string): void {
        let changed = false;

        for (const timer of this.timers.values()) {
            if (timer.taskFile === oldPath) {
                timer.taskFile = newPath;
                changed = true;
            }

            const renamedTaskId = TaskIdGenerator.renameFile(timer.taskId, oldPath, newPath);
            if (renamedTaskId !== timer.taskId) {
                timer.taskId = renamedTaskId;
                changed = true;
            }
        }

        if (changed) {
            this.persistTimersToStorage();
        }
    }

    private hasActiveTimerForTask(taskId: string, timerTargetId?: string): boolean {
        if (this.isIdleTimer(taskId)) {
            return this.timers.has(taskId);
        }

        if (this.timers.has(taskId)) {
            return true;
        }

        if (!timerTargetId) {
            return false;
        }

        for (const timer of this.timers.values()) {
            if (timer.timerTargetId === timerTargetId) {
                return true;
            }
        }

        return false;
    }

    private isIdleTimer(taskId: string): boolean {
        return taskId === TimerWidget.IDLE_TIMER_ID;
    }

    private hasNonIdleTimers(): boolean {
        for (const taskId of this.timers.keys()) {
            if (!this.isIdleTimer(taskId)) {
                return true;
            }
        }
        return false;
    }

    private startIdleTimer(): void {
        if (this.timers.has(TimerWidget.IDLE_TIMER_ID)) {
            return;
        }

        if (!this.container) {
            this.createContainer();
        }

        const idleTimer: IdleTimer = {
            id: TimerWidget.IDLE_TIMER_ID,
            taskId: TimerWidget.IDLE_TIMER_ID,
            taskName: 'Idle',
            taskOriginalText: '',
            taskFile: '',
            timerTargetId: undefined,
            autoGeneratedTargetId: false,
            startTimeMs: Date.now(),
            pausedElapsedTime: 0,
            phase: 'idle',
            isRunning: true,
            isExpanded: true,
            intervalId: null,
            customLabel: '',
            timerType: 'idle',
            elapsedTime: 0,
            recordMode: 'child',
            parserId: 'at-notation',
        };

        this.timers.set(TimerWidget.IDLE_TIMER_ID, idleTimer);
        this.startTimerTicker(TimerWidget.IDLE_TIMER_ID);
    }

    private stopIdleTimer(): void {
        const idleTimer = this.timers.get(TimerWidget.IDLE_TIMER_ID);
        if (!idleTimer) {
            return;
        }

        this.stopTimer(TimerWidget.IDLE_TIMER_ID);
        this.timers.delete(TimerWidget.IDLE_TIMER_ID);
    }

    private async ensureTimerTargetId(taskId: string): Promise<void> {
        const timer = this.timers.get(taskId);
        if (!timer) return;
        if (timer.taskId.startsWith('daily-')) return;

        if (timer.timerTargetId) {
            timer.autoGeneratedTargetId = this.isAutoManagedTimerTargetId(timer.timerTargetId);
            this.persistTimersToStorage();
            return;
        }

        if (timer.parserId === 'at-notation') {
            await this.ensureInlineTimerTargetId(timer);
            return;
        }

        if (timer.parserId === 'frontmatter') {
            await this.ensureFrontmatterTimerTargetId(timer);
        }
    }

    private async ensureInlineTimerTargetId(timer: TimerInstance): Promise<void> {
        const taskIndex = this.plugin.getTaskIndex();
        const currentTask = this.resolveInlineTaskForTimer(timer);
        if (!currentTask) return;

        if (currentTask.timerTargetId) {
            timer.taskId = currentTask.id;
            timer.taskFile = currentTask.file;
            timer.taskOriginalText = currentTask.originalText;
            timer.timerTargetId = currentTask.timerTargetId;
            timer.autoGeneratedTargetId = this.isAutoManagedTimerTargetId(currentTask.timerTargetId);
            this.persistTimersToStorage();
            return;
        }

        // Preserve user-defined non-timer block IDs and use them as stable lookup keys.
        if (currentTask.blockId) {
            timer.taskId = currentTask.id;
            timer.taskFile = currentTask.file;
            timer.taskOriginalText = currentTask.originalText;
            timer.timerTargetId = currentTask.blockId;
            timer.autoGeneratedTargetId = false;
            this.persistTimersToStorage();
            return;
        }

        const newTargetId = this.generateTimerTargetId();
        try {
            await taskIndex.updateTask(currentTask.id, { blockId: newTargetId });
            await taskIndex.waitForScan(currentTask.file);

            const updatedTask =
                this.findInlineTaskByTimerTargetId(currentTask.file, newTargetId)
                || this.resolveInlineTaskForTimer(timer);
            if (updatedTask) {
                timer.taskId = updatedTask.id;
                timer.taskFile = updatedTask.file;
                timer.taskOriginalText = updatedTask.originalText;
                timer.timerTargetId = newTargetId;
                timer.autoGeneratedTargetId = true;
                this.persistTimersToStorage();
            }
        } catch (error) {
            console.error('[TimerWidget] Failed to assign timer target ID for inline task:', error);
        }
    }

    private async ensureFrontmatterTimerTargetId(timer: TimerInstance): Promise<void> {
        const taskIndex = this.plugin.getTaskIndex();
        const currentTask = this.resolveFrontmatterTaskForTimer(timer);
        if (!currentTask) return;

        if (currentTask.timerTargetId) {
            timer.taskId = currentTask.id;
            timer.taskFile = currentTask.file;
            timer.timerTargetId = currentTask.timerTargetId;
            timer.autoGeneratedTargetId = this.isAutoManagedTimerTargetId(currentTask.timerTargetId);
            this.persistTimersToStorage();
            return;
        }

        const file = this.app.vault.getAbstractFileByPath(currentTask.file);
        if (!(file instanceof TFile)) return;

        const newTargetId = this.generateTimerTargetId();
        try {
            const timerTargetIdKey = this.plugin.settings.frontmatterTaskKeys.timerTargetId;
            // @ts-ignore - processFrontMatter is available in Obsidian API
            await this.app.fileManager.processFrontMatter(file, (frontmatter: any) => {
                frontmatter[timerTargetIdKey] = newTargetId;
            });
            await taskIndex.waitForScan(currentTask.file);

            const updatedTask =
                this.findFrontmatterTaskByTimerTargetId(newTargetId, currentTask.file)
                || this.resolveFrontmatterTaskForTimer(timer);
            if (updatedTask) {
                timer.taskId = updatedTask.id;
                timer.taskFile = updatedTask.file;
                timer.timerTargetId = newTargetId;
                timer.autoGeneratedTargetId = true;
                this.persistTimersToStorage();
            }
        } catch (error) {
            console.error('[TimerWidget] Failed to assign timer target ID for frontmatter task:', error);
        }
    }

    private resolveInlineTaskForTimer(timer: TimerInstance): Task | undefined {
        if (timer.parserId !== 'at-notation') return undefined;
        return this.resolver.resolveInlineTask(timer);
    }

    private resolveFrontmatterTaskForTimer(timer: TimerInstance): Task | undefined {
        if (timer.parserId !== 'frontmatter') return undefined;
        return this.resolver.resolveFrontmatterTask(timer);
    }

    private findInlineTaskByTimerTargetId(filePath: string, timerTargetId: string): Task | undefined {
        return this.plugin
            .getTaskIndex()
            .getTasks()
            .find((task) =>
                task.parserId === 'at-notation'
                && task.file === filePath
                && (task.timerTargetId === timerTargetId || task.blockId === timerTargetId)
            );
    }

    private findFrontmatterTaskByTimerTargetId(timerTargetId: string, filePath?: string): Task | undefined {
        return this.plugin
            .getTaskIndex()
            .getTasks()
            .find((task) =>
                task.parserId === 'frontmatter'
                && task.timerTargetId === timerTargetId
                && (!filePath || task.file === filePath)
            );
    }

    private getOrCreateDeviceId(): string {
        try {
            const existing = window.localStorage.getItem(TimerWidget.DEVICE_ID_KEY);
            if (existing && existing.trim()) {
                return existing;
            }
            const newId = this.generateStableId('dev');
            window.localStorage.setItem(TimerWidget.DEVICE_ID_KEY, newId);
            return newId;
        } catch {
            return 'dev-unknown';
        }
    }

    private resolveVaultFingerprint(): string {
        const adapter = this.app.vault.adapter;
        const basePath = adapter instanceof FileSystemAdapter ? adapter.getBasePath() : '';
        const fallbackName = this.app.vault.getName();
        const rawIdentity = basePath && basePath.trim() ? basePath : fallbackName;
        const normalizedIdentity = (rawIdentity || 'unknown-vault').trim().toLowerCase();
        return this.hashToHex(normalizedIdentity);
    }

    private hashToHex(raw: string): string {
        let hash = 5381;
        for (let i = 0; i < raw.length; i++) {
            hash = ((hash << 5) + hash) + raw.charCodeAt(i);
        }
        return (hash >>> 0).toString(16).padStart(8, '0');
    }

    private getStorageKey(): string {
        return `${TimerWidget.STORAGE_KEY_PREFIX}.v${TimerWidget.STORAGE_VERSION}:${this.vaultFingerprint}`;
    }

    private cleanupLegacyStorage(): void {
        try {
            window.localStorage.removeItem(TimerWidget.LEGACY_STORAGE_KEY);
        } catch {
            // noop
        }
    }

    private generateStableId(prefix: string): string {
        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
            return `${prefix}-${crypto.randomUUID()}`;
        }
        return `${prefix}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
    }

    private generateTimerTargetId(): string {
        const raw = this.generateStableId('target').replace(/^target-/, '');
        return `${TIMER_TARGET_ID_PREFIX}${raw}`.replace(/[^A-Za-z0-9-]/g, '');
    }

    private isAutoManagedTimerTargetId(timerTargetId?: string): boolean {
        return isTimerTargetId(timerTargetId);
    }

    private async cleanupGeneratedTargetId(timer: TimerInstance): Promise<void> {
        if (!timer.autoGeneratedTargetId) return;
        if (!timer.timerTargetId) return;
        if (!this.isAutoManagedTimerTargetId(timer.timerTargetId)) return;
        if (this.hasAnotherActiveTimerWithTarget(timer.timerTargetId)) return;

        if (timer.parserId === 'at-notation') {
            await this.removeInlineTimerTargetId(timer);
            return;
        }

        if (timer.parserId === 'frontmatter') {
            await this.removeFrontmatterTimerTargetId(timer);
        }
    }

    private hasAnotherActiveTimerWithTarget(timerTargetId: string): boolean {
        for (const timer of this.timers.values()) {
            if (timer.timerTargetId === timerTargetId) {
                return true;
            }
        }
        return false;
    }

    private async removeInlineTimerTargetId(timer: TimerInstance): Promise<void> {
        const taskIndex = this.plugin.getTaskIndex();
        let targetTask: Task | undefined;

        if (timer.taskFile) {
            targetTask = this.findInlineTaskByTimerTargetId(timer.taskFile, timer.timerTargetId!);
        }
        if (!targetTask) {
            targetTask = taskIndex
                .getTasks()
                .find((task) => task.parserId === 'at-notation' && task.timerTargetId === timer.timerTargetId);
        }
        if (!targetTask) return;

        if (targetTask.blockId !== timer.timerTargetId) {
            return;
        }

        try {
            await taskIndex.updateTask(targetTask.id, { blockId: undefined });
            await taskIndex.waitForScan(targetTask.file);
        } catch (error) {
            console.error('[TimerWidget] Failed to remove inline timer target ID:', error);
        }
    }

    private async removeFrontmatterTimerTargetId(timer: TimerInstance): Promise<void> {
        let targetPath = timer.taskFile;
        const targetTask = this.findFrontmatterTaskByTimerTargetId(timer.timerTargetId!);
        if (targetTask) {
            targetPath = targetTask.file;
        }
        if (!targetPath) return;

        const file = this.app.vault.getAbstractFileByPath(targetPath);
        if (!(file instanceof TFile)) return;

        try {
            const timerTargetIdKey = this.plugin.settings.frontmatterTaskKeys.timerTargetId;
            // @ts-ignore - processFrontMatter is available in Obsidian API
            await this.app.fileManager.processFrontMatter(file, (frontmatter: any) => {
                if (frontmatter?.[timerTargetIdKey] === timer.timerTargetId) {
                    delete frontmatter[timerTargetIdKey];
                }
            });
            await this.plugin.getTaskIndex().waitForScan(targetPath);
        } catch (error) {
            console.error('[TimerWidget] Failed to remove frontmatter timer target ID:', error);
        }
    }

    private persistTimersToStorage(): void {
        const storageKey = this.getStorageKey();
        try {
            if (this.timers.size === 0) {
                window.localStorage.removeItem(storageKey);
                return;
            }

            const payload: PersistedTimerState = {
                version: TimerWidget.STORAGE_VERSION,
                ownerDeviceId: this.deviceId,
                vaultFingerprint: this.vaultFingerprint,
                updatedAtMs: Date.now(),
                timers: Array.from(this.timers.values()).map((timer) => this.toPersistedTimer(timer))
            };

            window.localStorage.setItem(storageKey, JSON.stringify(payload));
        } catch (error) {
            console.error('[TimerWidget] Failed to persist timers:', error);
        }
    }

    private restoreTimersFromStorage(): void {
        const storageKey = this.getStorageKey();
        try {
            const raw = window.localStorage.getItem(storageKey);
            if (!raw) return;

            const parsed = JSON.parse(raw) as PersistedTimerState | {
                version?: number;
                ownerDeviceId?: string;
                vaultFingerprint?: string;
                updatedAtMs?: number;
                timers?: PersistedTimer[];
            };
            const normalized = this.migratePersistedState(parsed);

            if (
                !normalized
                || normalized.version !== TimerWidget.STORAGE_VERSION
                || normalized.vaultFingerprint !== this.vaultFingerprint
                || !Array.isArray(normalized.timers)
            ) {
                window.localStorage.removeItem(storageKey);
                return;
            }
            if (normalized.ownerDeviceId !== this.deviceId) {
                return;
            }

            for (const persisted of normalized.timers) {
                const timer = this.fromPersistedTimer(persisted);
                if (!timer) continue;

                this.reconcileRestoredTimer(timer);
                this.timers.set(timer.id, timer);
            }

            if (this.timers.size === 0) {
                this.persistTimersToStorage();
                return;
            }

            if (!this.container) {
                this.createContainer();
            }

            for (const [timerId, timer] of this.timers) {
                if (timer.isRunning) {
                    if (timer.timerType === 'pomodoro' && timer.timeRemaining <= 0) {
                        void this.handlePomodoroComplete(timerId, timer);
                    } else if (timer.timerType === 'interval' && timer.segmentTimeRemaining <= 0) {
                        void this.handleIntervalSegmentComplete(timerId, timer);
                    } else {
                        this.startTimerTicker(timerId);
                    }
                }

                if (!this.isIdleTimer(timerId) && !timer.timerTargetId && !timer.taskId.startsWith('daily-')) {
                    void this.ensureTimerTargetId(timerId);
                }
            }

            this.render();
        } catch (error) {
            window.localStorage.removeItem(storageKey);
            console.error('[TimerWidget] Failed to restore timers:', error);
        }
    }

    private migratePersistedState(
        parsed: PersistedTimerState | { version?: number; ownerDeviceId?: string; vaultFingerprint?: string; updatedAtMs?: number; timers?: PersistedTimer[] }
    ): PersistedTimerState | null {
        if (!parsed || !Array.isArray(parsed.timers)) {
            return null;
        }

        if (parsed.version === TimerWidget.STORAGE_VERSION) {
            return parsed as PersistedTimerState;
        }

        if (parsed.version === 3) {
            const migratedTimers = parsed.timers.map((timer) => ({
                ...timer,
                phase: timer.phase ?? timer.mode ?? 'idle'
            }));
            return {
                version: TimerWidget.STORAGE_VERSION,
                ownerDeviceId: parsed.ownerDeviceId ?? this.deviceId,
                vaultFingerprint: parsed.vaultFingerprint ?? this.vaultFingerprint,
                updatedAtMs: parsed.updatedAtMs ?? Date.now(),
                timers: migratedTimers
            };
        }

        return null;
    }

    private toPersistedTimer(timer: TimerInstance): PersistedTimer {
        const common: PersistedTimer = {
            id: timer.id,
            taskId: timer.taskId,
            taskName: timer.taskName,
            taskOriginalText: timer.taskOriginalText,
            taskFile: timer.taskFile,
            timerTargetId: timer.timerTargetId,
            autoGeneratedTargetId: timer.autoGeneratedTargetId,
            startTimeMs: timer.startTimeMs,
            pausedElapsedTime: timer.pausedElapsedTime,
            phase: timer.phase,
            isRunning: timer.isRunning,
            isExpanded: timer.isExpanded,
            customLabel: timer.customLabel,
            timerType: timer.timerType,
            recordMode: timer.recordMode,
            parserId: timer.parserId
        };

        switch (timer.timerType) {
            case 'pomodoro':
                return {
                    ...common,
                    timeRemaining: timer.timeRemaining,
                    totalTime: timer.totalTime,
                    autoRepeat: timer.autoRepeat
                };
            case 'countup':
                return {
                    ...common,
                    elapsedTime: timer.elapsedTime
                };
            case 'countdown':
                return {
                    ...common,
                    timeRemaining: timer.timeRemaining,
                    totalTime: timer.totalTime,
                    elapsedTime: timer.elapsedTime
                };
            case 'interval':
                return {
                    ...common,
                    groups: timer.groups,
                    currentGroupIndex: timer.currentGroupIndex,
                    currentSegmentIndex: timer.currentSegmentIndex,
                    currentRepeatIndex: timer.currentRepeatIndex,
                    segmentTimeRemaining: timer.segmentTimeRemaining,
                    totalElapsedTime: timer.totalElapsedTime,
                    totalDuration: timer.totalDuration
                };
            case 'idle':
            default:
                return {
                    ...common,
                    elapsedTime: timer.elapsedTime
                };
        }
    }

    private fromPersistedTimer(persisted: PersistedTimer): TimerInstance | null {
        if (!persisted || !persisted.id || !persisted.taskId) {
            return null;
        }

        const taskId = persisted.taskId;
        if (!this.isIdleTimer(taskId) && !taskId.startsWith('daily-') && !TaskIdGenerator.parse(taskId)) {
            return null;
        }

        const phase = (persisted.phase ?? persisted.mode ?? 'idle') as TimerPhase;
        const common = {
            id: persisted.id,
            taskId,
            taskName: persisted.taskName || 'Untitled',
            taskOriginalText: persisted.taskOriginalText || '',
            taskFile: persisted.taskFile || '',
            timerTargetId: persisted.timerTargetId,
            autoGeneratedTargetId: persisted.autoGeneratedTargetId ?? this.isAutoManagedTimerTargetId(persisted.timerTargetId),
            startTimeMs: persisted.startTimeMs || 0,
            pausedElapsedTime: persisted.pausedElapsedTime || 0,
            phase,
            isRunning: !!persisted.isRunning,
            isExpanded: persisted.isExpanded !== false,
            intervalId: null,
            customLabel: persisted.customLabel || '',
            recordMode: persisted.recordMode || 'child',
            parserId: persisted.parserId || 'at-notation'
        };

        switch (persisted.timerType) {
            case 'pomodoro': {
                return {
                    ...common,
                    timerType: 'pomodoro',
                    timeRemaining: Math.max(0, persisted.timeRemaining ?? this.plugin.settings.pomodoroWorkMinutes * 60),
                    totalTime: Math.max(1, persisted.totalTime ?? this.plugin.settings.pomodoroWorkMinutes * 60),
                    autoRepeat: !!persisted.autoRepeat
                };
            }
            case 'countdown': {
                const totalTime = Math.max(1, persisted.totalTime ?? this.plugin.settings.pomodoroWorkMinutes * 60);
                const elapsedTime = Math.max(0, persisted.elapsedTime ?? persisted.pausedElapsedTime ?? 0);
                const timeRemaining = persisted.timeRemaining ?? (totalTime - elapsedTime);
                return {
                    ...common,
                    timerType: 'countdown',
                    timeRemaining,
                    totalTime,
                    elapsedTime
                };
            }
            case 'interval': {
                const groups = this.normalizeIntervalGroups(persisted.groups);
                const intervalTimer: IntervalTimer = {
                    ...common,
                    timerType: 'interval',
                    groups,
                    currentGroupIndex: Math.max(0, persisted.currentGroupIndex ?? 0),
                    currentSegmentIndex: Math.max(0, persisted.currentSegmentIndex ?? 0),
                    currentRepeatIndex: Math.max(0, persisted.currentRepeatIndex ?? 0),
                    segmentTimeRemaining: Math.max(0, persisted.segmentTimeRemaining ?? groups[0].segments[0].durationSeconds),
                    totalElapsedTime: Math.max(0, persisted.totalElapsedTime ?? 0),
                    totalDuration: Math.max(1, persisted.totalDuration ?? this.computeIntervalTotalDuration(groups))
                };
                const segment = this.getCurrentIntervalSegment(intervalTimer);
                if (!segment) {
                    return null;
                }
                if (intervalTimer.segmentTimeRemaining <= 0) {
                    intervalTimer.segmentTimeRemaining = segment.durationSeconds;
                }
                return intervalTimer;
            }
            case 'idle': {
                return {
                    ...common,
                    timerType: 'idle',
                    elapsedTime: Math.max(0, persisted.elapsedTime ?? persisted.pausedElapsedTime ?? 0),
                    phase: 'idle'
                };
            }
            case 'countup':
            default: {
                return {
                    ...common,
                    timerType: 'countup',
                    elapsedTime: Math.max(0, persisted.elapsedTime ?? persisted.pausedElapsedTime ?? 0)
                };
            }
        }
    }

    private reconcileRestoredTimer(timer: TimerInstance): void {
        if (!timer.isRunning) {
            if (timer.timerType === 'countup' || timer.timerType === 'idle') {
                timer.elapsedTime = Math.max(timer.elapsedTime, timer.pausedElapsedTime);
            } else if (timer.timerType === 'countdown') {
                timer.elapsedTime = Math.max(timer.elapsedTime, timer.pausedElapsedTime);
                timer.timeRemaining = timer.totalTime - timer.elapsedTime;
                timer.phase = timer.timeRemaining < 0 ? 'idle' : 'work';
            } else if (timer.timerType === 'pomodoro') {
                timer.timeRemaining = Math.max(0, timer.totalTime - timer.pausedElapsedTime);
            } else if (timer.timerType === 'interval') {
                const segment = this.getCurrentIntervalSegment(timer);
                if (segment) {
                    timer.segmentTimeRemaining = Math.max(0, segment.durationSeconds - timer.pausedElapsedTime);
                    timer.totalElapsedTime = Math.min(
                        timer.totalDuration,
                        this.computeIntervalCompletedDuration(timer) + Math.min(segment.durationSeconds, timer.pausedElapsedTime)
                    );
                }
            }
            return;
        }

        if (timer.startTimeMs <= 0) {
            timer.startTimeMs = Date.now();
        }

        const now = Date.now();
        const currentSessionElapsed = Math.floor((now - timer.startTimeMs) / 1000);
        const totalElapsed = Math.max(0, timer.pausedElapsedTime + currentSessionElapsed);

        switch (timer.timerType) {
            case 'countup':
            case 'idle':
                timer.elapsedTime = totalElapsed;
                break;
            case 'countdown':
                timer.elapsedTime = totalElapsed;
                timer.timeRemaining = timer.totalTime - totalElapsed;
                timer.phase = timer.timeRemaining < 0 ? 'idle' : 'work';
                break;
            case 'pomodoro':
                timer.timeRemaining = Math.max(0, timer.totalTime - totalElapsed);
                break;
            case 'interval': {
                const segment = this.getCurrentIntervalSegment(timer);
                if (!segment) {
                    timer.segmentTimeRemaining = 0;
                    timer.totalElapsedTime = timer.totalDuration;
                    break;
                }
                timer.segmentTimeRemaining = Math.max(0, segment.durationSeconds - totalElapsed);
                timer.totalElapsedTime = Math.min(
                    timer.totalDuration,
                    this.computeIntervalCompletedDuration(timer) + Math.min(segment.durationSeconds, totalElapsed)
                );
                break;
            }
            default:
                break;
        }
    }

    private showSettingsMenu(e: MouseEvent, taskId: string): void {
        const timer = this.timers.get(taskId);
        if (!timer || timer.timerType !== 'pomodoro') return;

        TimerSettingsMenu.showPomodoroSettings({
            app: this.app,
            plugin: this.plugin,
            timer,
            event: e,
            onPersist: () => this.persistTimersToStorage(),
            onRender: () => this.render()
        });
    }

    destroy(): void {
        for (const [taskId] of this.timers) {
            this.stopTimer(taskId);
        }
        this.intervalPrepareBaseElapsed.clear();
        this.timers.clear();
        if (this.container) {
            this.container.remove();
            this.container = null;
        }
    }
}
